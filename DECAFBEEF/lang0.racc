class Lang0

token TYPE NAME NUM '='
token 'if' 'else'
token '(' ')'
token OPERATOR
token ';' ',' 'const'
token '{' '}' 'return'

prechigh
  left '*' '/'
  left '+' '-'
preclow

start s
rule

s : decls                                   { result = Root.new("Start", nil, val[0]) }
  | decls statement_list decls              { result = Root.new("Start", nil, val[0], val[1], val[2]) }

decls : TYPE decl_list ';' decls            { result = Decls.new("Decls", val[0], val[1], val[3])}
      | "const" TYPE decl_list ';' decls    { result = Decls.new("Decls", val[0], val[2], val[4])}
      |

decl_list : decl                            { result = DeclList.new("Decl List", nil, val[0])}
          | decl_list ',' decl              { result = DeclList.new("Decl List", nil, val[0], val[2])}

decl : NAME                                 { result = Dec.new("Assignment", nil, DirectDec.new("NAME", val[0]))}
     | NAME '=' expr                        { result = Dec.new("=", nil, DirectDec.new("NAME", val[0]),val[2])}

statement_list : statement                  { result = StateList.new("Statement List", nil, val[0]) } 
  | statement_list statement                { result = StateList.new("Statement List", nil, val[0], val[1]) }

statement : cmpnd_state                                { result = StateList.new("Statement List", nil, val[0]) }
  | 'if' '(' expr ')' cmpnd_state                      { result = IfNode.new("If", nil, val[2], val[4], Lambda.new("Lambda", nil))}
  | 'if' '(' expr ')' cmpnd_state 'else' cmpnd_state   { result = IfNode.new("IfElse", nil, val[2], val[4], val[6], Lambda.new("Lambda", nil))}
  | 'while' '(' expr ')' cmpnd_state                   { result = WhileNode.new("While", nil, val[2], val[4], Lambda.new("Lambda", nil)) }
  | 'return' ';'                                       { result = Expr.new("Expr", val[0]) }
  | 'return' expr ';'                                  { result = Expr.new("Expr", val[0], val[1]) }
  | expr ';'                                           { result = Expr.new("Expr", nil, val[0]) }

cmpnd_state : '{' decls '}'                            { result = CmpndState.new("Compound Statements", nil, val[1]) }
  | '{' decls statement_list '}'                       { result = CmpndState.new("Compound Statements", nil, val[1], val[2]) }


expr :  expr OPERATOR expr                  { result = Expr.new("Operator", val[1], val[0], val[2]) }
     | expr '=' expr                        { result = Expr.new("Operator", val[1], val[0], val[2]) }
     | expr '+' expr                        { result = Expr.new("Operator", val[1], val[0], val[2]) }
     | expr '-' expr                        { result = Expr.new("Operator", val[1], val[0], val[2]) }
     | expr '*' expr                        { result = Expr.new("Operator", val[1], val[0], val[2]) }
     | expr '/' expr                        { result = Expr.new("Operator", val[1], val[0], val[2]) }
     | '(' expr ')'                         { result = val[1] }
     | NAME                                 { result = Expr.new("NAME", val[0]) }
     | NUM                                  { result = Expr.new("NUM", val[0]) }



# s : decs states                                     { result = Root.new("S", nil, val[0], val[1]) }

# decs : TYPE decbody ';' decs                        { result = Decs.new("DEC", val[0], val[0], val[1], val[3]) }
#     | 'const' TYPE decbody ';' decs                 { result = Decs.new("CONSTDEC", val[1], val[1], val[2], val[4]) }
#     |                                               {result = nil}

# decbody : NAME ',' decbody                          { result = DecBody.new("DECBODY", nil, Expr.new(val[0], val[0]), val[2]) }
#     | assignment ',' decbody                        { result = DecBody.new("DECBODY", nil, Expr.new("ASS", nil, val[0]), val[2]) }
#     | NAME                                          { result = Expr.new(val[0], val[0]) }
# 	| assignment                                    { result = Expr.new("ASS", nil, val[0]) }

# assignment : NAME '=' expr                          { result = Assign.new("=", nil, Expr.new(val[0], val[0]), val[2]) }

# states : rxpr ';' states                            { result = States.new("STATES", nil, val[0], val[2]) }
#       | if states                                   { result = States.new("STATES", "block", val[0], val[1]) }
#       |                                             {}

# rxpr : 'return' expr                                { result = RExpr.new("RETURN", nil, val[0]) }
#      | expr                                         { result = val[0] }

# expr :  expr OPERATOR expr                          { result = Expr.new(val[1], nil, val[0], val[2]) }
#      | expr '+' expr                                { result = Expr.new("+", nil, val[0], val[2]) }
#      | expr '-' expr                                { result = Expr.new("-", nil, val[0], val[2]) }
#      | expr '*' expr                                { result = Expr.new("*", nil, val[0], val[2]) }
#      | expr '/' expr                                { result = Expr.new("/", nil, val[0], val[2]) }
#      | '(' expr ')'                                 { result = val[1] }
#      | NAME                                         { result = Expr.new(val[0], val[0], val[0]) }
#      | NUM                                          { result = Expr.new(val[0], val[0]) }
#      | assignment                                   { result = Expr.new("ASS", nil, val[0]) }

# if : 'if' '(' expr ')' '{' states '}' 'else'  rxpr ';'      { result = IfNode.new("IFELSE", nil, val[2], val[5], val[8]) }
#    | 'if' '(' expr ')' '{' states '}' 'else'  if            { result = IfNode.new("IFELSE", nil, val[2], val[5], val[8]) }
#    | 'if' '(' expr ')' '{' states '}' 'else' '{' states '}' { result = IfNode.new("IFELSE", nil, val[2], val[5], val[9]) }
#    | 'if' '(' expr ')' '{' states '}'                       { result = IfNode.new("IF", nil, val[2], val[5]) }

end

---- header ----

require "./AST.rb"
require "./lang0.rex"
require "./symtab.rb"
require "./ir.rb"

---- footer ----

class Lang0WithErrors < Lang0
  def initialize
    @yydebug = true
  end
  # https://github.com/JasonBarnabe/racc/blob/aef0fb1a9d20770bf0416286e8085c6f26fa7363/lib/racc/parser.rb#L542
  def on_error(t, val, vstack)
    errcontext = (@ss.pre_match[-10..-1] || @ss.pre_match) +
  				@ss.matched + @ss.post_match[0..9]
    raise ParseError, sprintf("\nparse error on value %s (%s) " +
  							"around \"%s\"",
  							val.inspect, token_to_str(t) || '?',
  							errcontext)
  end
end

outa = File.open("OUTPUT.a", "w")
outp = File.open("OUTPUT.p", "w")
outerr = File.open("OUTPUT.err", "w")
outir = File.open("OUTPUT.ir", "w")

exe = Lang0WithErrors.new
    begin
      ast = Ast.new(exe.scan_str($stdin.read))
      # root = exe.scan_str($stdin.read)
      sym = SymbolTable.new
      ast.accept(sym, outa, outp, outir)
      ast.accept(AstVisitorPass1.new, outa, outp, outir)
      ast.accept(AstVisitorPass2.new, outa, outp, outir)
      # ast.accept(AstVisitorPassIR.new, outa, outp, outir)
      # p sym.table
      # p sym.namespace
      ir = IR.new(outir, sym)
      ast.accept(ir, outa, outp, outir)
    rescue ParseError => e
      puts 'Parsing error'
      puts e.message
      puts "\nStack Trace"
      puts e.backtrace.inspect
      outerr << 'Parsing error' << "\n"
      outerr << e.message << "\n"
      outerr << e.backtrace.inspect << "\n"
      raise SystemExit.new(1)
    end

outa.close
outp.close
outerr.close
outir.close

# statement
#   | compound_statement
#   | IF '(' expression ')' statement
#   | IF '(' expression ')' statement ELSE statement
#   | WHILE '(' expression ')' statement
#   | RETURN ';'
#   | RETURN expression ';'
#   | expression ';'
#   | ';'
#   ;

# expression
#   : assignment_expression
#   | expression ',' assignment_expression
#   ;

# compound_statement
#   : '{' '}'
#   | '{' statement_list '}'
#   | '{' declaration_list '}'
#   | '{' declaration_list statement_list '}'
#   ;

# declaration_list
#   : declaration
#   | declaration_list declaration
#   ;

# statement_list
#   : statement
#   | statement_list statement
#   ;



