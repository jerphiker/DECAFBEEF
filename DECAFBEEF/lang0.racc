class Lang0

token TYPE NAME NUM '='
token 'if' 'else'
token '(' ')'
token OPERATOR
token ';' ',' 'const'
token '{' '}' 'return'

prechigh
  left '*' '/'
  left '+' '-'
preclow

start s
rule

s : decs states                                     { result = Root.new("S", nil, val[0], val[1]) }

decs : TYPE decbody ';' decs                        { result = Decs.new("DEC", val[0], val[0], val[1], val[3]) }
    | 'const' TYPE decbody ';' decs                 { result = Decs.new("CONSTDEC", val[1], val[1], val[2], val[4]) }
    |                                               {result = nil}

decbody : NAME ',' decbody                          { result = DecBody.new("DECBODY", nil, Expr.new(val[0], val[0]), val[2]) }
    | NAME                                          { result = Expr.new(val[0], val[0]) }
	| assignment                                    { result = Expr.new("ASS", nil, val[0]) }

assignment : NAME '=' expr                          { result = Assign.new("=", nil, Expr.new(val[0], val[0]), val[2]) }

states : rxpr ';' states                            { result = States.new("STATES", nil, val[0], val[2]) }
      | if states                                   { result = States.new("STATES", "block", val[0], val[1]) }
      |                                             {}

rxpr : 'return' expr                                { result = RExpr.new("RETURN", nil, val[0]) }
     | expr                                         { result = val[0] }

expr :  expr OPERATOR expr                          { result = Expr.new(val[1], nil, val[0], val[2]) }
     | expr '+' expr                                { result = Expr.new("+", nil, val[0], val[2]) }
     | expr '-' expr                                { result = Expr.new("-", nil, val[0], val[2]) }
     | expr '*' expr                                { result = Expr.new("*", nil, val[0], val[2]) }
     | expr '/' expr                                { result = Expr.new("/", nil, val[0], val[2]) }
     | '(' expr ')'                                 { result = val[1] }
     | NAME                                         { result = Expr.new(val[0], val[0], val[0]) }
     | NUM                                          { result = Expr.new(val[0], val[0]) }
     | assignment                                   { result = Expr.new("ASS", nil, val[0]) }

if : 'if' '(' expr ')' '{' states '}' 'else'  rxpr ';'      { result = IfNode.new("IFELSE", nil, val[2], val[5], val[8]) }
   | 'if' '(' expr ')' '{' states '}' 'else'  if            { result = IfNode.new("IFELSE", nil, val[2], val[5], val[8]) }
   | 'if' '(' expr ')' '{' states '}' 'else' '{' states '}' { result = IfNode.new("IFELSE", nil, val[2], val[5], val[9]) }
   | 'if' '(' expr ')' '{' states '}'                       { result = IfNode.new("IF", nil, val[2], val[5]) }

end

---- header ----

require "./AST.rb"
require "./lang0.rex"
require "./symtab.rb"

---- footer ----

outa = File.open("OUTPUT.a", "w")
outp = File.open("OUTPUT.p", "w")
outerr = File.open("OUTPUT.err", "w")
outir = File.open("OUTPUT.err", "w")

exe = Lang0.new
    begin
      ast = Ast.new(exe.scan_str($stdin.read))
      # root = exe.scan_str($stdin.read)
      sym = SymbolTable.new
      ast.accept(sym)
      # p sym.table
      # p sym.namespace
      ast.root.get_ids(outa, outp)
      ast.root.get_children(outa, outp)
    rescue ParseError => e
      puts 'Parsing error'
      puts e.message
      puts e.backtrace.inspect
      outerr << 'Parsing error' << "\n"
      outerr << e.message << "\n"
      outerr << e.backtrace.inspect << "\n"
    end

outa.close
outp.close
outerr.close
outir.close

# str = gets
# while str do
#   puts "Inputed string = #{str}"

#   if str != nil
#     begin
#       exe.scan_str(str)
#     rescue ParseError => e
#       puts 'Parsing error'
#       puts e.message
#       puts e.backtrace.inspect
#     end

#     puts
#   end
#   str = gets
# end

# vim:ft=racc:
